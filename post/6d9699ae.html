<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=6.7.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.7.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.7.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.7.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":"10f"},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="简介Git 是什么？Git 是一个开源的分布式版本控制系统。 什么是版本控制？版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 什么是分布式版本控制系统？介绍分布式版本控制系统前，有必要先了解一下传统的集中式版本控制系统。集中化的版本控制系统，诸如 CVS，Subversion 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连">
<meta name="keywords" content="git">
<meta property="og:type" content="article">
<meta property="og:title" content="git从入门到精通">
<meta property="og:url" content="http://yoursite.com/post/6d9699ae.html">
<meta property="og:site_name" content="cacacai">
<meta property="og:description" content="简介Git 是什么？Git 是一个开源的分布式版本控制系统。 什么是版本控制？版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 什么是分布式版本控制系统？介绍分布式版本控制系统前，有必要先了解一下传统的集中式版本控制系统。集中化的版本控制系统，诸如 CVS，Subversion 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/images/pasted-19.png">
<meta property="og:image" content="http://yoursite.com/images/pasted-21.png">
<meta property="og:image" content="http://yoursite.com/images/pasted-23.png">
<meta property="og:updated_time" content="2019-03-10T08:29:37.025Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="git从入门到精通">
<meta name="twitter:description" content="简介Git 是什么？Git 是一个开源的分布式版本控制系统。 什么是版本控制？版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 什么是分布式版本控制系统？介绍分布式版本控制系统前，有必要先了解一下传统的集中式版本控制系统。集中化的版本控制系统，诸如 CVS，Subversion 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连">
<meta name="twitter:image" content="http://yoursite.com/images/pasted-19.png">






  <link rel="canonical" href="http://yoursite.com/post/6d9699ae.html">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>git从入门到精通 | cacacai</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">cacacai</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/post/6d9699ae.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cacacai">
      <meta itemprop="description" content="夏天的飞鸟飞到我的窗前唱歌又飞去了秋天的黄叶它们没有什么可唱只叹息一声飞落在那里">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cacacai">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">git从入门到精通

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-10 15:08:00 / 修改时间：16:29:37" itemprop="dateCreated datePublished" datetime="2019-03-10T15:08:00+08:00">2019-03-10</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/git/" itemprop="url" rel="index"><span itemprop="name">git</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <a href="/post/6d9699ae.html#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/post/6d9699ae.html" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数"></span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长"></span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="Git-是什么？"><a href="#Git-是什么？" class="headerlink" title="Git 是什么？"></a>Git 是什么？</h2><p>Git 是一个开源的分布式版本控制系统。</p>
<h2 id="什么是版本控制？"><a href="#什么是版本控制？" class="headerlink" title="什么是版本控制？"></a>什么是版本控制？</h2><p>版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。</p>
<h2 id="什么是分布式版本控制系统？"><a href="#什么是分布式版本控制系统？" class="headerlink" title="什么是分布式版本控制系统？"></a>什么是分布式版本控制系统？</h2><p>介绍分布式版本控制系统前，有必要先了解一下传统的集中式版本控制系统。<br>集中化的版本控制系统，诸如 CVS，Subversion 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。<br>这么做最显而易见的缺点是中央服务器的单点故障。如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。要是中央服务器的磁盘发生故障，碰巧没做备份，或者备份不够及时，就会有丢失数据的风险。最坏的情况是彻底丢失整个项目的所有历史更改记录。<br><a id="more"></a><br>分布式版本控制系统的客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。因为每一次的提取操作，实际上都是一次对代码仓库的完整备份。</p>
<h2 id="为什么使用-Git？"><a href="#为什么使用-Git？" class="headerlink" title="为什么使用 Git？"></a>为什么使用 Git？</h2><p>Git 是分布式的。这是 Git 和其它非分布式的版本控制系统，例如 svn，cvs 等，最核心的区别。分布式带来以下好处：<br>工作时不需要联网<br>首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件 A，你的同事也在他的电脑上改了文件 A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。<br>更加安全<br>集中式版本控制系统，一旦中央服务器出了问题，所有人都无法工作。<br>分布式版本控制系统，每个人电脑中都有完整的版本库，所以某人的机器挂了，并不影响其它人。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="Debian-Ubuntu-环境安装"><a href="#Debian-Ubuntu-环境安装" class="headerlink" title="Debian/Ubuntu 环境安装"></a>Debian/Ubuntu 环境安装</h2><p>如果你使用的系统是 Debian/Ubuntu ， 安装命令为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \</span><br><span class="line">&gt; libz-dev libssl-dev</span><br><span class="line">$ apt-get install git-core</span><br><span class="line">$ git --version</span><br><span class="line">git version 1.8.1.2</span><br></pre></td></tr></table></figure></p>
<h2 id="Centos-RedHat-环境安装"><a href="#Centos-RedHat-环境安装" class="headerlink" title="Centos/RedHat 环境安装"></a>Centos/RedHat 环境安装</h2><p>如果你使用的系统是 Centos/RedHat ，安装命令为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ yum install curl-devel expat-devel gettext-devel \</span><br><span class="line">&gt; openssl-devel zlib-devel</span><br><span class="line">$ yum -y install git-core</span><br><span class="line">$ git --version</span><br><span class="line">git version 1.7.1</span><br></pre></td></tr></table></figure></p>
<h2 id="Windows-环境安装"><a href="#Windows-环境安装" class="headerlink" title="Windows 环境安装"></a>Windows 环境安装</h2><p>在Git 官方下载地址下载 exe 安装包。按照安装向导安装即可。<br>建议安装 Git Bash 这个 git 的命令行工具。</p>
<h2 id="Mac-环境安装"><a href="#Mac-环境安装" class="headerlink" title="Mac 环境安装"></a>Mac 环境安装</h2><p>在Git 官方下载地址下载 mac 安装包。按照安装向导安装即可。</p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>Git 自带一个 git config 的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置：</p>
<ul>
<li>/etc/gitconfig 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果使用带有 –system 选项的 git config 时，它会从此文件读写配置变量。</li>
<li>~/.gitconfig 或 ~/.config/git/config 文件：只针对当前用户。 可以传递 –global 选项让 Git 读写此文件。</li>
<li>当前使用仓库的 Git 目录中的 config 文件（就是 .git/config）：针对该仓库。</li>
</ul>
<p>每一个级别覆盖上一级别的配置，所以 .git/config 的配置变量会覆盖 /etc/gitconfig 中的配置变量。<br>在 Windows 系统中，Git 会查找 $HOME 目录下（一般情况下是 C:\Users\$USER）的 .gitconfig 文件。 Git 同样也会寻找 /etc/gitconfig 文件，但只限于 MSys 的根目录下，即安装 Git 时所选的目标位置。</p>
<h2 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h2><p>当安装完 Git 应该做的第一件事就是设置你的用户名称与邮件地址。 这样做很重要，因为每一个 Git 的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;John Doe&quot;</span><br><span class="line">$ git config --global user.email johndoe@example.com</span><br></pre></td></tr></table></figure></p>
<p>再次强调，如果使用了 –global 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 –global 选项的命令来配置。<br>很多 GUI 工具都会在第一次运行时帮助你配置这些信息。</p>
<h2 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h2><p>.gitignore 文件可能从字面含义也不难猜出：这个文件里配置的文件或目录，会自动被 git 所忽略，不纳入版本控制。<br>在日常开发中，我们的项目经常会产生一些临时文件，如编译 Java 产生的 * .class 文件，又或是 IDE 自动生成的隐藏目录（Intellij 的 .idea 目录、Eclipse 的 .settings 目录等）等等。这些文件或目录实在没必要纳入版本管理。在这种场景下，你就需要用到 .gitignore 配置来过滤这些文件或目录。<br>配置的规则很简单，也没什么可说的，看几个例子，自然就明白了。<br>这里推荐一下 Github 的开源项目：<a href="https://github.com/github/gitignore" target="_blank" rel="noopener">https://github.com/github/gitignore</a><br>在这里，你可以找到很多常用的模板，如：Java、Nodejs、C++ 的 .gitignore 模板等等。</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>个人认为，对于 Git 这个版本工具，再不了解原理的情况下，直接去学习命令行，可能会一头雾水。所以，本文特意将原理放在命令使用章节之前讲解。</p>
<h2 id="版本库"><a href="#版本库" class="headerlink" title="版本库"></a>版本库</h2><p>当你一个项目到本地或创建一个 git 项目，项目目录下会有一个隐藏的 .git 子目录。这个目录是 git 用来跟踪管理版本库的，千万不要手动修改。</p>
<h2 id="哈希值"><a href="#哈希值" class="headerlink" title="哈希值"></a>哈希值</h2><p>Git 中所有数据在存储前都计算校验和，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。 这个功能建构在 Git 底层，是构成 Git 哲学不可或缺的部分。 若你在传送过程中丢失信息或损坏文件，Git 就能发现。<br>Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）。 这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来。 SHA-1 哈希看起来是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24b9da6552252987aa493b52f8696cd6d3b00373</span><br></pre></td></tr></table></figure></p>
<p>Git 中使用这种哈希值的情况很多，你将经常看到这种哈希值。 实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。</p>
<h2 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h2><p>在 GIt 中，你的文件可能会处于三种状态之一：</p>
<ul>
<li>已修改（modified） - 已修改表示修改了文件，但还没保存到数据库中。</li>
<li>已暂存（staged） - 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li>
<li>已提交（committed） - 已提交表示数据已经安全的保存在本地数据库中。</li>
</ul>
<h2 id="工作区域"><a href="#工作区域" class="headerlink" title="工作区域"></a>工作区域</h2><p>与文件状态对应的，不同状态的文件在 Git 中处于不同的工作区域。</p>
<ul>
<li>工作区（working） - 当你 git clone 一个项目到本地，相当于在本地克隆了项目的一个副本。工作区是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</li>
<li>暂存区（staging） - 暂存区是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。 有时候也被称作‘索引’’，不过一般说法还是叫暂存区。</li>
<li>本地仓库（local） - 提交更新，找到暂存区域的文件，将快照永久性存储到 Git 本地仓库。</li>
<li>远程仓库（remote） - 以上几个工作区都是在本地。为了让别人可以看到你的修改，你需要将你的更新推 送到远程仓库。同理，如果你想同步别人的修改，你需要从远程仓库拉取更新。</li>
</ul>
<p><img src="/images/pasted-19.png" alt="upload successful"></p>
<h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><p>国外网友制作了一张 Git Cheat Sheet，总结很精炼，各位不妨收藏一下。<br>本节选择性介绍 git 中比较常用的命令行场景。</p>
<p><img src="/images/pasted-21.png" alt="upload successful"></p>
<h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><p>克隆一个已创建的仓库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 通过 SSH</span><br><span class="line">$ git clone ssh://user@domain.com/repo.git</span><br><span class="line"></span><br><span class="line">#通过 HTTP</span><br><span class="line">$ git clone http://domain.com/user/repo.git</span><br><span class="line"></span><br><span class="line">创建一个新的本地仓库：</span><br><span class="line">$ git init</span><br></pre></td></tr></table></figure></p>
<h2 id="添加修改"><a href="#添加修改" class="headerlink" title="添加修改"></a>添加修改</h2><p>添加修改到暂存区：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 把指定文件添加到暂存区</span><br><span class="line">$ git add xxx</span><br><span class="line"></span><br><span class="line"># 把当前所有修改添加到暂存区</span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line"># 把所有修改添加到暂存区</span><br><span class="line">$ git add -A</span><br></pre></td></tr></table></figure></p>
<p>提交修改到本地仓库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 提交本地的所有修改</span><br><span class="line">$ git commit -a</span><br><span class="line"></span><br><span class="line"># 提交之前已标记的变化</span><br><span class="line">$ git commit</span><br><span class="line"></span><br><span class="line"># 附加消息提交</span><br><span class="line">$ git commit -m &apos;commit message&apos;</span><br></pre></td></tr></table></figure></p>
<h2 id="储藏"><a href="#储藏" class="headerlink" title="储藏"></a>储藏</h2><p>有时，我们需要在同一个项目的不同分支上工作。当需要切换分支时，偏偏本地的工作还没有完成，此时，提交修改显得不严谨，但是不提交代码又无法切换分支。这时，你可以使用 git stash 将本地的修改内容作为草稿储藏起来。<br>官方称之为储藏，但我个人更喜欢称之为存草稿。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 1. 将修改作为当前分支的草稿保存</span><br><span class="line">$ git stash</span><br><span class="line"></span><br><span class="line"># 2. 查看草稿列表</span><br><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on master: 6fae349 :memo: Writing docs.</span><br><span class="line"></span><br><span class="line"># 3.1 删除草稿</span><br><span class="line">$ git stash drop stash@&#123;0&#125;</span><br><span class="line"></span><br><span class="line"># 3.2 读取草稿</span><br><span class="line">$ git stash apply stash@&#123;0&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><p>撤销本地修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 移除缓存区的所有文件（i.e. 撤销上次git add）</span><br><span class="line">$ git reset HEAD</span><br><span class="line"></span><br><span class="line"># 将HEAD重置到上一次提交的版本，并将之后的修改标记为未添加到缓存区的修改</span><br><span class="line">$ git reset &lt;commit&gt;</span><br><span class="line"></span><br><span class="line"># 将HEAD重置到上一次提交的版本，并保留未提交的本地修改</span><br><span class="line">$ git reset --keep &lt;commit&gt;</span><br><span class="line"></span><br><span class="line"># 放弃工作目录下的所有修改</span><br><span class="line">$ git reset --hard HEAD</span><br><span class="line"></span><br><span class="line"># 将HEAD重置到指定的版本，并抛弃该版本之后的所有修改</span><br><span class="line">$ git reset --hard &lt;commit-hash&gt;</span><br><span class="line"></span><br><span class="line"># 用远端分支强制覆盖本地分支</span><br><span class="line">$ git reset --hard &lt;remote/branch&gt; e.g., upstream/master, origin/my-feature</span><br><span class="line"></span><br><span class="line"># 放弃某个文件的所有本地修改</span><br><span class="line">$ git checkout HEAD &lt;file&gt;</span><br></pre></td></tr></table></figure></p>
<p>删除添加.gitignore文件前错误提交的文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git rm -r --cached .</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m &quot;remove xyz file&quot;</span><br></pre></td></tr></table></figure></p>
<p>撤销远程修改（创建一个新的提交，并回滚到指定版本）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git revert &lt;commit-hash&gt;</span><br></pre></td></tr></table></figure></p>
<p>彻底删除指定版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 执行下面命令后，commit-hash 提交后的记录都会被彻底删除，使用需谨慎</span><br><span class="line">$ git reset --hard &lt;commit-hash&gt;</span><br><span class="line">$ git push -f</span><br></pre></td></tr></table></figure></p>
<h2 id="更新与推送"><a href="#更新与推送" class="headerlink" title="更新与推送"></a>更新与推送</h2><p>更新：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 下载远程端版本，但不合并到HEAD中</span><br><span class="line">$ git fetch &lt;remote&gt;</span><br><span class="line"></span><br><span class="line"># 将远程端版本合并到本地版本中</span><br><span class="line">$ git pull origin master</span><br><span class="line"></span><br><span class="line"># 以rebase方式将远端分支与本地合并</span><br><span class="line">$ git pull --rebase &lt;remote&gt; &lt;branch&gt;</span><br></pre></td></tr></table></figure></p>
<p>推送：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 将本地版本推送到远程端</span><br><span class="line">$ git push remote &lt;remote&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line"># 删除远程端分支</span><br><span class="line">$ git push &lt;remote&gt; :&lt;branch&gt; (since Git v1.5.0)</span><br><span class="line">$ git push &lt;remote&gt; --delete &lt;branch&gt; (since Git v1.7.0)</span><br><span class="line"></span><br><span class="line"># 发布标签</span><br><span class="line">$ git push --tags</span><br></pre></td></tr></table></figure></p>
<h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><p>显示工作路径下已修改的文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br></pre></td></tr></table></figure></p>
<p>显示与上次提交版本文件的不同：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br></pre></td></tr></table></figure></p>
<p>显示提交历史：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 从最新提交开始，显示所有的提交记录（显示hash， 作者信息，提交的标题和时间）</span><br><span class="line">$ git log</span><br><span class="line"></span><br><span class="line"># 显示某个用户的所有提交</span><br><span class="line">$ git log --author=&quot;username&quot;</span><br><span class="line"></span><br><span class="line"># 显示某个文件的所有修改</span><br><span class="line">$ git log -p &lt;file&gt;</span><br></pre></td></tr></table></figure></p>
<p>显示搜索内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 从当前目录的所有文件中查找文本内容</span><br><span class="line">$ git grep &quot;Hello&quot;</span><br><span class="line"></span><br><span class="line"># 在某一版本中搜索文本</span><br><span class="line">$ git grep &quot;Hello&quot; v2.5</span><br></pre></td></tr></table></figure></p>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>增删查分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有的分支</span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"># 列出所有的远端分支</span><br><span class="line">$ git branch -r</span><br><span class="line"></span><br><span class="line"># 基于当前分支创建新分支</span><br><span class="line">$ git branch &lt;new-branch&gt;</span><br><span class="line"></span><br><span class="line"># 基于远程分支创建新的可追溯的分支</span><br><span class="line">$ git branch --track &lt;new-branch&gt; &lt;remote-branch&gt;</span><br><span class="line"></span><br><span class="line"># 删除本地分支</span><br><span class="line">$ git branch -d &lt;branch&gt;</span><br><span class="line"></span><br><span class="line"># 强制删除本地分支，将会丢失未合并的修改</span><br><span class="line">$ git branch -D &lt;branch&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="切换分支："><a href="#切换分支：" class="headerlink" title="切换分支："></a>切换分支：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 切换分支</span><br><span class="line">$ git checkout &lt;branch&gt;</span><br><span class="line"></span><br><span class="line"># 创建并切换到新分支</span><br><span class="line">$ git checkout -b &lt;branch&gt;</span><br></pre></td></tr></table></figure>
<p>标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 给当前版本打标签</span><br><span class="line">$ git tag &lt;tag-name&gt;</span><br><span class="line"></span><br><span class="line"># 给当前版本打标签并附加消息</span><br><span class="line">$ git tag -a &lt;tag-name&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="合并与重置"><a href="#合并与重置" class="headerlink" title="合并与重置"></a>合并与重置</h2><blockquote>
<p>merge 与 rebase 虽然是 git 常用功能，但是强烈建议不要使用 git 命令来完成这项工作。<br>因为如果出现代码冲突，在没有代码比对工具的情况下，实在太艰难了。<br>你可以考虑使用各种 Git GUI 工具。</p>
</blockquote>
<p>合并：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 将分支合并到当前HEAD中</span><br><span class="line">$ git merge &lt;branch&gt;</span><br></pre></td></tr></table></figure></p>
<p>重置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 将当前HEAD版本重置到分支中，请勿重置已发布的提交</span><br><span class="line">$ git rebase &lt;branch&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><p>Github 作为最著名的代码开源协作社区，在程序员圈想必无人不知，无人不晓。</p>
<p>这里不赘述 Github 的用法，确实有不会用的新手同学，可以参考官方教程：<a href="https://guides.github.com/" target="_blank" rel="noopener">https://guides.github.com/</a></p>
<h2 id="clone-方式"><a href="#clone-方式" class="headerlink" title="clone 方式"></a>clone 方式</h2><p>Git 支持三种协议：HTTPS / SSH / GIT<br>而 Github 上支持 HTTPS 和 SSH。<br>HTTPS 这种方式要求你每次 push 时都要输入用户名、密码，有些繁琐。<br>而 SSH 要求你本地生成证书，然后在你的 Github 账户中注册。第一次配置麻烦是麻烦了点，但是以后就免去了每次 push 需要输入用户名、密码的繁琐。</p>
<p>以下介绍以下，如何生成证书，以及在 Github 中注册。</p>
<h2 id="生成-SSH-公钥"><a href="#生成-SSH-公钥" class="headerlink" title="生成 SSH 公钥"></a>生成 SSH 公钥</h2><p>如前所述，许多 Git 服务器都使用 SSH 公钥进行认证。 为了向 Git 服务器提供 SSH 公钥，如果某系统用户尚未拥有密钥，必须事先为其生成一份。 这个过程在所有操作系统上都是相似的。 首先，你需要确认自己是否已经拥有密钥。 默认情况下，用户的 SSH 密钥存储在其 ~/.ssh 目录下。 进入该目录并列出其中内容，你便可以快速确认自己是否已拥有密钥：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/.ssh</span><br><span class="line">$ ls</span><br><span class="line">authorized_keys2  id_dsa       known_hosts</span><br><span class="line">config            id_dsa.pub</span><br></pre></td></tr></table></figure></p>
<p>我们需要寻找一对以 id_dsa 或 id_rsa 命名的文件，其中一个带有 .pub 扩展名。 .pub 文件是你的公钥，另一个则是私钥。 如果找不到这样的文件（或者根本没有 .ssh 目录），你可以通过运行 ssh-keygen 程序来创建它们。在 Linux/Mac 系统中，ssh-keygen 随 SSH 软件包提供；在 Windows 上，该程序包含于 MSysGit 软件包中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/home/schacon/.ssh/id_rsa):</span><br><span class="line">Created directory &apos;/home/schacon/.ssh&apos;.</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved in /home/schacon/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved in /home/schacon/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">d0:82:24:8e:d7:f1:bb:9b:33:53:96:93:49:da:9b:e3 schacon@mylaptop.local</span><br></pre></td></tr></table></figure></p>
<p>首先 ssh-keygen 会确认密钥的存储位置（默认是 .ssh/id_rsa），然后它会要求你输入两次密钥口令。如果你不想在使用密钥时输入口令，将其留空即可。<br>现在，进行了上述操作的用户需要将各自的公钥发送给任意一个 Git 服务器管理员（假设服务器正在使用基于公钥的 SSH 验证设置）。 他们所要做的就是复制各自的 .pub 文件内容，并将其通过邮件发送。 公钥看起来是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cat ~/.ssh/id_rsa.pub</span><br><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSU</span><br><span class="line">GPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3</span><br><span class="line">Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XA</span><br><span class="line">t3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/En</span><br><span class="line">mZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbx</span><br><span class="line">NrRFi9wrf+M7Q== schacon@mylaptop.local</span><br></pre></td></tr></table></figure></p>
<p>在你的 Github 账户中，依次点击 <b>Settings &gt; SSH and GPG keys &gt; New SSH key</b><br>然后，将上面生成的公钥内容粘贴到 Key 编辑框并保存。至此大功告成。<br>后面，你在克隆你的 Github 项目时使用 SSH 方式即可。<br>如果觉得我的讲解还不够细致，可以参考：<a href="https://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account/" target="_blank" rel="noopener">https://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account/</a></p>
<h1 id="最佳实践-Git-Flow"><a href="#最佳实践-Git-Flow" class="headerlink" title="最佳实践 Git Flow"></a>最佳实践 Git Flow</h1><p>详细内容，可以参考这篇文章：Git 在团队中的最佳实践–如何正确使用 Git Flow</p>
<p>Git 在实际开发中的最佳实践策略 Git Flow 可以归纳为以下：</p>
<ul>
<li>master 分支 - 也就是我们经常使用的主线分支，这个分支是最近发布到生产环境的代码，这个分支只能从其他分支合并，不能在这个分支直接修改。</li>
<li>develop 分支 - 这个分支是我们的主开发分支，包含所有要发布到下一个 release 的代码，这个分支主要是从其他分支合并代码过来，比如 feature 分支。</li>
<li>feature 分支 - 这个分支主要是用来开发一个新的功能，一旦开发完成，我们合并回 develop 分支进入下一个 release。</li>
<li>release 分支 - 当你需要一个发布一个新 release 的时候，我们基于 Develop 分支创建一个 release 分支，完成 release 后，我们合并到 master 和 develop 分支。</li>
<li><p>hotfix 分支 - 当我们在 master 发现新的 Bug 时候，我们需要创建一个 hotfix, 完成 hotfix 后，我们合并回 master 和 develop 分支，所以 hotfix 的改动会进入下一个 release。</p>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="编辑提交-editting-commits"><a href="#编辑提交-editting-commits" class="headerlink" title="编辑提交(editting commits)"></a>编辑提交(editting commits)</h2><h3 id="我刚才提交了什么"><a href="#我刚才提交了什么" class="headerlink" title="我刚才提交了什么"></a>我刚才提交了什么</h3><p>如果你用 git commit -a 提交了一次变化(changes)，而你又不确定到底这次提交了哪些内容。 你就可以用下面的命令显示当前HEAD上的最近一次的提交(commit):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(master)$ git show</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log -n1 -p</span><br></pre></td></tr></table></figure></p>
<h3 id="我的提交信息-commit-message-写错了"><a href="#我的提交信息-commit-message-写错了" class="headerlink" title="我的提交信息(commit message)写错了"></a>我的提交信息(commit message)写错了</h3><p>如果你的提交信息(commit message)写错了且这次提交(commit)还没有推(push), 你可以通过下面的方法来修改提交信息(commit message):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure></p>
<p>这会打开你的默认编辑器, 在这里你可以编辑信息. 另一方面, 你也可以用一条命令一次完成:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend -m &apos;xxxxxxx&apos;</span><br></pre></td></tr></table></figure></p>
<p>如果你已经推(push)了这次提交(commit), 你可以修改这次提交(commit)然后强推(force push), 但是不推荐这么做。</p>
<h3 id="我提交-commit-里的用户名和邮箱不对"><a href="#我提交-commit-里的用户名和邮箱不对" class="headerlink" title="我提交(commit)里的用户名和邮箱不对"></a>我提交(commit)里的用户名和邮箱不对</h3><p>如果这只是单个提交(commit)，修改它：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend --author &quot;New Authorname &lt;authoremail@mydomain.com&gt;&quot;</span><br></pre></td></tr></table></figure></p>
<p>如果你需要修改所有历史, 参考 ‘git filter-branch’的指南页.</p>
<h3 id="我想从一个提交-commit-里移除一个文件"><a href="#我想从一个提交-commit-里移除一个文件" class="headerlink" title="我想从一个提交(commit)里移除一个文件"></a>我想从一个提交(commit)里移除一个文件</h3><p>通过下面的方法，从一个提交(commit)里移除一个文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout HEAD^ myfile</span><br><span class="line">$ git add -A</span><br><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure></p>
<p>这将非常有用，当你有一个开放的补丁(open patch)，你往上面提交了一个不必要的文件，你需要强推(force push)去更新这个远程补丁。<br>我想删除我的的最后一次提交(commit)<br>如果你需要删除推了的提交(pushed commits)，你可以使用下面的方法。可是，这会不可逆的改变你的历史，也会搞乱那些已经从该仓库拉取(pulled)了的人的历史。简而言之，如果你不是很确定，千万不要这么做。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD^ --hard</span><br><span class="line">$ git push -f [remote] [branch]</span><br></pre></td></tr></table></figure></p>
<p>如果你还没有推到远程, 把 Git 重置(reset)到你最后一次提交前的状态就可以了(同时保存暂存的变化):<br>(my-branch*)$ git reset –soft HEAD@{1}</p>
<p>这只能在没有推送之前有用. 如果你已经推了, 唯一安全能做的是 git revert SHAofBadCommit， 那会创建一个新的提交(commit)用于撤消前一个提交的所有变化(changes)； 或者, 如果你推的这个分支是 rebase-safe 的 (例如： 其它开发者不会从这个分支拉), 只需要使用 git push -f； 更多, 请参考 the above section。</p>
<h3 id="删除任意提交-commit"><a href="#删除任意提交-commit" class="headerlink" title="删除任意提交(commit)"></a>删除任意提交(commit)</h3><p>同样的警告：不到万不得已的时候不要这么做.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase --onto SHA1_OF_BAD_COMMIT^ SHA1_OF_BAD_COMMIT</span><br><span class="line">$ git push -f [remote] [branch]</span><br></pre></td></tr></table></figure></p>
<p>或者做一个 交互式 rebase 删除那些你想要删除的提交(commit)里所对应的行。</p>
<h3 id="我尝试推一个修正后的提交-amended-commit-到远程，但是报错："><a href="#我尝试推一个修正后的提交-amended-commit-到远程，但是报错：" class="headerlink" title="我尝试推一个修正后的提交(amended commit)到远程，但是报错："></a>我尝试推一个修正后的提交(amended commit)到远程，但是报错：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">To https://github.com/yourusername/repo.git</span><br><span class="line">! [rejected]        mybranch -&gt; mybranch (non-fast-forward)</span><br><span class="line">error: failed to push some refs to &apos;https://github.com/tanay1337/webmaker.org.git&apos;</span><br><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. Integrate the remote changes (e.g.</span><br><span class="line">hint: &apos;git pull ...&apos;) before pushing again.</span><br><span class="line">hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details.</span><br></pre></td></tr></table></figure>
<p>注意, rebasing(见下面)和修正(amending)会用一个新的提交(commit)代替旧的, 所以如果之前你已经往远程仓库上推过一次修正前的提交(commit)，那你现在就必须强推(force push) (-f)。 注意 – 总是 确保你指明一个分支!<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(my-branch)$ git push origin mybranch -f</span><br></pre></td></tr></table></figure></p>
<p>一般来说, 要避免强推. 最好是创建和推(push)一个新的提交(commit)，而不是强推一个修正后的提交。后者会使那些与该分支或该分支的子分支工作的开发者，在源历史中产生冲突。</p>
<h3 id="我意外的做了一次硬重置-hard-reset-，我想找回我的内容"><a href="#我意外的做了一次硬重置-hard-reset-，我想找回我的内容" class="headerlink" title="我意外的做了一次硬重置(hard reset)，我想找回我的内容"></a>我意外的做了一次硬重置(hard reset)，我想找回我的内容</h3><p>如果你意外的做了 git reset –hard, 你通常能找回你的提交(commit), 因为 Git 对每件事都会有日志，且都会保存几天。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(master)$ git reflog</span><br></pre></td></tr></table></figure></p>
<p>你将会看到一个你过去提交(commit)的列表, 和一个重置的提交。 选择你想要回到的提交(commit)的 SHA，再重置一次:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(master)$ git reset --hard SHA1234</span><br></pre></td></tr></table></figure></p>
<p>这样就完成了。</p>
<h2 id="暂存-Staging"><a href="#暂存-Staging" class="headerlink" title="暂存(Staging)"></a>暂存(Staging)</h2><h3 id="我需要把暂存的内容添加到上一次的提交-commit"><a href="#我需要把暂存的内容添加到上一次的提交-commit" class="headerlink" title="我需要把暂存的内容添加到上一次的提交(commit)"></a>我需要把暂存的内容添加到上一次的提交(commit)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(my-branch*)$ git commit --amend</span><br></pre></td></tr></table></figure>
<h3 id="我想要暂存一个新文件的一部分，而不是这个文件的全部"><a href="#我想要暂存一个新文件的一部分，而不是这个文件的全部" class="headerlink" title="我想要暂存一个新文件的一部分，而不是这个文件的全部"></a>我想要暂存一个新文件的一部分，而不是这个文件的全部</h3><p>一般来说, 如果你想暂存一个文件的一部分, 你可这样做:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add --patch filename.x</span><br></pre></td></tr></table></figure></p>
<p>-p 简写。这会打开交互模式， 你将能够用 s 选项来分隔提交(commit)； 然而, 如果这个文件是新的, 会没有这个选择， 添加一个新文件时, 这样做:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add -N filename.x</span><br></pre></td></tr></table></figure></p>
<p>然后, 你需要用 e 选项来手动选择需要添加的行，执行 git diff –cached 将会显示哪些行暂存了哪些行只是保存在本地了。</p>
<h3 id="我想把在一个文件里的变化-changes-加到两个提交-commit-里"><a href="#我想把在一个文件里的变化-changes-加到两个提交-commit-里" class="headerlink" title="我想把在一个文件里的变化(changes)加到两个提交(commit)里"></a>我想把在一个文件里的变化(changes)加到两个提交(commit)里</h3><figure class="highlight plain"><figcaption><span>add``` 会把整个文件加入到一个提交. ```git add -p``` 允许交互式的选择你想要提交的部分.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">### 我想把暂存的内容变成未暂存，把未暂存的内容暂存起来</span><br><span class="line">这个有点困难， 我能想到的最好的方法是先 stash 未暂存的内容， 然后重置(reset)，再 pop 第一步 stashed 的内容, 最后再 add 它们。</span><br></pre></td></tr></table></figure>
<p>$ git stash -k<br>$ git reset –hard<br>$ git stash pop<br>$ git add -A<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">### 未暂存(Unstaged)的内容</span><br><span class="line">我想把未暂存的内容移动到一个新分支</span><br></pre></td></tr></table></figure></p>
<p>$ git checkout -b my-branch<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">### 我想把未暂存的内容移动到另一个已存在的分支</span><br></pre></td></tr></table></figure></p>
<p>$ git stash<br>$ git checkout my-branch<br>$ git stash pop<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">### 我想丢弃本地未提交的变化(uncommitted changes)</span><br><span class="line">如果你只是想重置源(origin)和你本地(local)之间的一些提交(commit)，你可以：</span><br></pre></td></tr></table></figure></p>
<h2 id="one-commit"><a href="#one-commit" class="headerlink" title="one commit"></a>one commit</h2><p>(my-branch)$ git reset –hard HEAD^</p>
<h2 id="two-commits"><a href="#two-commits" class="headerlink" title="two commits"></a>two commits</h2><p>(my-branch)$ git reset –hard HEAD^^</p>
<h2 id="four-commits"><a href="#four-commits" class="headerlink" title="four commits"></a>four commits</h2><p>(my-branch)$ git reset –hard HEAD~4</p>
<h2 id="or"><a href="#or" class="headerlink" title="or"></a>or</h2><p>(master)$ git checkout -f<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">重置某个特殊的文件, 你可以用文件名做为参数:</span><br></pre></td></tr></table></figure></p>
<p>$ git reset filename<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">### 我想丢弃某些未暂存的内容</span><br><span class="line">如果你想丢弃工作拷贝中的一部分内容，而不是全部。</span><br><span class="line">签出(checkout)不需要的内容，保留需要的。</span><br></pre></td></tr></table></figure></p>
<p>$ git checkout -p</p>
<h2 id="Answer-y-to-all-of-the-snippets-you-want-to-drop"><a href="#Answer-y-to-all-of-the-snippets-you-want-to-drop" class="headerlink" title="Answer y to all of the snippets you want to drop"></a>Answer y to all of the snippets you want to drop</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">另外一个方法是使用 stash， Stash 所有要保留下的内容, 重置工作拷贝, 重新应用保留的部分。</span><br></pre></td></tr></table></figure>
<p>$ git stash -p</p>
<h2 id="Select-all-of-the-snippets-you-want-to-save"><a href="#Select-all-of-the-snippets-you-want-to-save" class="headerlink" title="Select all of the snippets you want to save"></a>Select all of the snippets you want to save</h2><p>$ git reset –hard<br>$ git stash pop<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">或者, stash 你不需要的部分, 然后 stash drop。</span><br></pre></td></tr></table></figure></p>
<p>$ git stash -p</p>
<h2 id="Select-all-of-the-snippets-you-don’t-want-to-save"><a href="#Select-all-of-the-snippets-you-don’t-want-to-save" class="headerlink" title="Select all of the snippets you don’t want to save"></a>Select all of the snippets you don’t want to save</h2><p>$ git stash drop<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">## 分支(Branches)</span><br><span class="line">### 我从错误的分支拉取了内容，或把内容拉取到了错误的分支</span><br><span class="line">这是另外一种使用 git reflog 情况，找到在这次错误拉(pull) 之前 HEAD 的指向。</span><br></pre></td></tr></table></figure></p>
<p>(master)$ git reflog<br>ab7555f HEAD@{0}: pull origin wrong-branch: Fast-forward<br>c5bc55a HEAD@{1}: checkout: checkout message goes here<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">重置分支到你所需的提交(desired commit):</span><br></pre></td></tr></table></figure></p>
<p>$ git reset –hard c5bc55a<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">完成。</span><br><span class="line">### 我想扔掉本地的提交(commit)，以便我的分支与远程的保持一致</span><br><span class="line">先确认你没有推(push)你的内容到远程。</span><br></pre></td></tr></table></figure></p>
<p>git status 会显示你领先(ahead)源(origin)多少个提交:<br>(my-branch)$ git status</p>
<h2 id="On-branch-my-branch"><a href="#On-branch-my-branch" class="headerlink" title="On branch my-branch"></a>On branch my-branch</h2><h2 id="Your-branch-is-ahead-of-‘origin-my-branch’-by-2-commits"><a href="#Your-branch-is-ahead-of-‘origin-my-branch’-by-2-commits" class="headerlink" title="Your branch is ahead of ‘origin/my-branch’ by 2 commits."></a>Your branch is ahead of ‘origin/my-branch’ by 2 commits.</h2><h2 id="use-“git-push”-to-publish-your-local-commits"><a href="#use-“git-push”-to-publish-your-local-commits" class="headerlink" title="(use “git push” to publish your local commits)"></a>(use “git push” to publish your local commits)</h2><p>#<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一种方法是:</span><br></pre></td></tr></table></figure></p>
<p>(master)$ git reset –hard origin/my-branch<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">### 我需要提交到一个新分支，但错误的提交到了 master</span><br><span class="line">在 master 下创建一个新分支，不切换到新分支,仍在 master 下:</span><br></pre></td></tr></table></figure></p>
<p>(master)$ git branch my-branch<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">把 master 分支重置到前一个提交:</span><br></pre></td></tr></table></figure></p>
<p>(master)$ git reset –hard HEAD^<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HEAD^ 是 HEAD^1 的简写，你可以通过指定要设置的HEAD来进一步重置。</span><br><span class="line">或者, 如果你不想使用 HEAD^, 找到你想重置到的提交(commit)的 hash(git log 能够完成)， 然后重置到这个 hash。 使用git push 同步内容到远程。</span><br><span class="line">例如, master 分支想重置到的提交的 hash 为a13b85e:</span><br></pre></td></tr></table></figure></p>
<p>(master)$ git reset –hard a13b85e<br>HEAD is now at a13b85e<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">签出(checkout)刚才新建的分支继续工作:</span><br></pre></td></tr></table></figure></p>
<p>(master)$ git checkout my-branch<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">### 我想保留来自另外一个 ref-ish 的整个文件</span><br><span class="line">假设你正在做一个原型方案(原文为 working spike (see note)), 有成百的内容，每个都工作得很好。现在, 你提交到了一个分支，保存工作内容:</span><br></pre></td></tr></table></figure></p>
<p>(solution)$ git add -A &amp;&amp; git commit -m “Adding all changes from this spike into one big commit.”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">当你想要把它放到一个分支里 (可能是feature, 或者 develop), 你关心是保持整个文件的完整，你想要一个大的提交分隔成比较小。</span><br><span class="line">假设你有:</span><br><span class="line"></span><br><span class="line">分支 solution, 拥有原型方案， 领先 develop 分支。</span><br><span class="line">分支 develop, 在这里你应用原型方案的一些内容。</span><br><span class="line"></span><br><span class="line">我去可以通过把内容拿到你的分支里，来解决这个问题:</span><br></pre></td></tr></table></figure></p>
<p>(develop)$ git checkout solution – file1.txt<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这会把这个文件内容从分支 solution 拿到分支 develop 里来:</span><br></pre></td></tr></table></figure></p>
<h2 id="On-branch-develop"><a href="#On-branch-develop" class="headerlink" title="On branch develop"></a>On branch develop</h2><h2 id="Your-branch-is-up-to-date-with-‘origin-develop’"><a href="#Your-branch-is-up-to-date-with-‘origin-develop’" class="headerlink" title="Your branch is up-to-date with ‘origin/develop’."></a>Your branch is up-to-date with ‘origin/develop’.</h2><h2 id="Changes-to-be-committed"><a href="#Changes-to-be-committed" class="headerlink" title="Changes to be committed:"></a>Changes to be committed:</h2><h2 id="use-“git-reset-HEAD-…”-to-unstage"><a href="#use-“git-reset-HEAD-…”-to-unstage" class="headerlink" title="(use “git reset HEAD …” to unstage)"></a>(use “git reset HEAD <file>…” to unstage)</file></h2><p>#</p>
<h2 id="modified-file1-txt"><a href="#modified-file1-txt" class="headerlink" title="modified:   file1.txt"></a>modified:   file1.txt</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">然后, 正常提交。</span><br></pre></td></tr></table></figure>
<p>Note: Spike solutions are made to analyze or solve the problem. These solutions are used for estimation and discarded once everyone gets clear visualization of the problem. ~ Wikipedia.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我把几个提交(commit)提交到了同一个分支，而这些提交应该分布在不同的分支里</span><br><span class="line">假设你有一个master分支， 执行git log, 你看到你做过两次提交:</span><br></pre></td></tr></table></figure></p>
<p>(master)$ git log</p>
<p>commit e3851e817c451cc36f2e6f3049db528415e3c114<br>Author: Alex Lee <a href="mailto:&#97;&#x6c;&#x65;&#120;&#x6c;&#x65;&#x65;&#x40;&#x65;&#x78;&#97;&#109;&#112;&#x6c;&#101;&#x2e;&#x63;&#x6f;&#x6d;" target="_blank" rel="noopener">&#97;&#x6c;&#x65;&#120;&#x6c;&#x65;&#x65;&#x40;&#x65;&#x78;&#97;&#109;&#112;&#x6c;&#101;&#x2e;&#x63;&#x6f;&#x6d;</a><br>Date:   Tue Jul 22 15:39:27 2014 -0400</p>
<pre><code>Bug #21 - Added CSRF protection
</code></pre><p>commit 5ea51731d150f7ddc4a365437931cd8be3bf3131<br>Author: Alex Lee <a href="mailto:&#x61;&#108;&#101;&#x78;&#108;&#101;&#x65;&#64;&#101;&#120;&#97;&#x6d;&#x70;&#108;&#x65;&#46;&#x63;&#x6f;&#109;" target="_blank" rel="noopener">&#x61;&#108;&#101;&#x78;&#108;&#101;&#x65;&#64;&#101;&#120;&#97;&#x6d;&#x70;&#108;&#x65;&#46;&#x63;&#x6f;&#109;</a><br>Date:   Tue Jul 22 15:39:12 2014 -0400</p>
<pre><code>Bug #14 - Fixed spacing on title
</code></pre><p>commit a13b85e984171c6e2a1729bb061994525f626d14<br>Author: Aki Rose <a href="mailto:&#97;&#x6b;&#x69;&#x72;&#x6f;&#115;&#101;&#64;&#x65;&#120;&#97;&#x6d;&#x70;&#x6c;&#x65;&#x2e;&#99;&#x6f;&#109;" target="_blank" rel="noopener">&#97;&#x6b;&#x69;&#x72;&#x6f;&#115;&#101;&#64;&#x65;&#120;&#97;&#x6d;&#x70;&#x6c;&#x65;&#x2e;&#99;&#x6f;&#109;</a><br>Date:   Tue Jul 21 01:12:48 2014 -0400</p>
<pre><code>First commit
</code></pre> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">让我们用提交 hash(commit hash)标记 bug (e3851e8 for #21, 5ea5173 for #14).</span><br><span class="line">首先, 我们把master分支重置到正确的提交(a13b85e):</span><br></pre></td></tr></table></figure>
<p>(master)$ git reset –hard a13b85e<br>HEAD is now at a13b85e<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">现在, 我们对 bug #21 创建一个新的分支:</span><br></pre></td></tr></table></figure></p>
<p>(master)$ git checkout -b 21<br>(21)$<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接着, 我们用 cherry-pick 把对 bug #21 的提交放入当前分支。 这意味着我们将应用(apply)这个提交(commit)，仅仅这一个提交(commit)，直接在 HEAD 上面。</span><br></pre></td></tr></table></figure></p>
<p>(21)$ git cherry-pick e3851e8<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这时候, 这里可能会产生冲突， 参见交互式 rebasing 章 冲突节 解决冲突.</span><br><span class="line">再者， 我们为 bug #14 创建一个新的分支, 也基于master分支</span><br></pre></td></tr></table></figure></p>
<p>(21)$ git checkout master<br>(master)$ git checkout -b 14<br>(14)$<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最后, 为 bug #14 执行 cherry-pick:</span><br></pre></td></tr></table></figure></p>
<p>(14)$ git cherry-pick 5ea5173<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">### 我想删除上游(upstream)分支被删除了的本地分支</span><br><span class="line">一旦你在 github 上面合并(merge)了一个 pull request, 你就可以删除你 fork 里被合并的分支。 如果你不准备继续在这个分支里工作, 删除这个分支的本地拷贝会更干净，使你不会陷入工作分支和一堆陈旧分支的混乱之中。</span><br></pre></td></tr></table></figure></p>
<p>$ git fetch -p<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">### 我不小心删除了我的分支</span><br><span class="line">如果你定期推送到远程, 多数情况下应该是安全的，但有些时候还是可能删除了还没有推到远程的分支。 让我们先创建一个分支和一个新的文件:</span><br></pre></td></tr></table></figure></p>
<p>(master)$ git checkout -b my-branch<br>(my-branch)$ git branch<br>(my-branch)$ touch foo.txt<br>(my-branch)$ ls<br>README.md foo.txt<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">添加文件并做一次提交</span><br></pre></td></tr></table></figure></p>
<p>(my-branch)$ git add .<br>(my-branch)$ git commit -m ‘foo.txt added’<br>(my-branch)$ foo.txt added<br> 1 files changed, 1 insertions(+)<br> create mode 100644 foo.txt<br>(my-branch)$ git log</p>
<p>commit 4e3cd85a670ced7cc17a2b5d8d3d809ac88d5012<br>Author: siemiatj <a href="mailto:&#x73;&#105;&#x65;&#109;&#x69;&#97;&#x74;&#106;&#x40;&#101;&#x78;&#x61;&#x6d;&#x70;&#108;&#x65;&#x2e;&#99;&#111;&#109;" target="_blank" rel="noopener">&#x73;&#105;&#x65;&#109;&#x69;&#97;&#x74;&#106;&#x40;&#101;&#x78;&#x61;&#x6d;&#x70;&#108;&#x65;&#x2e;&#99;&#111;&#109;</a><br>Date:   Wed Jul 30 00:34:10 2014 +0200</p>
<pre><code>foo.txt added
</code></pre><p>commit 69204cdf0acbab201619d95ad8295928e7f411d5<br>Author: Kate Hudson <a href="mailto:&#x6b;&#x61;&#x74;&#x65;&#x68;&#117;&#x64;&#x73;&#111;&#110;&#x40;&#101;&#x78;&#x61;&#x6d;&#112;&#x6c;&#x65;&#46;&#x63;&#x6f;&#109;" target="_blank" rel="noopener">&#x6b;&#x61;&#x74;&#x65;&#x68;&#117;&#x64;&#x73;&#111;&#110;&#x40;&#101;&#x78;&#x61;&#x6d;&#112;&#x6c;&#x65;&#46;&#x63;&#x6f;&#109;</a><br>Date:   Tue Jul 29 13:14:46 2014 -0400</p>
<pre><code>Fixes #6: Force pushing after amending commits
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">现在我们切回到主(master)分支，‘不小心的’删除my-branch分支</span><br></pre></td></tr></table></figure>
<p>(my-branch)$ git checkout master<br>Switched to branch ‘master’<br>Your branch is up-to-date with ‘origin/master’.<br>(master)$ git branch -D my-branch<br>Deleted branch my-branch (was 4e3cd85).<br>(master)$ echo oh noes, deleted my branch!<br>oh noes, deleted my branch!<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在这时候你应该想起了reflog, 一个升级版的日志，它存储了仓库(repo)里面所有动作的历史。</span><br></pre></td></tr></table></figure></p>
<p>(master)$ git reflog<br>69204cd HEAD@{0}: checkout: moving from my-branch to master<br>4e3cd85 HEAD@{1}: commit: foo.txt added<br>69204cd HEAD@{2}: checkout: moving from master to my-branch<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">正如你所见，我们有一个来自删除分支的提交 hash(commit hash)，接下来看看是否能恢复删除了的分支。</span><br></pre></td></tr></table></figure></p>
<p>(master)$ git checkout -b my-branch-help<br>Switched to a new branch ‘my-branch-help’<br>(my-branch-help)$ git reset –hard 4e3cd85<br>HEAD is now at 4e3cd85 foo.txt added<br>(my-branch-help)$ ls<br>README.md foo.txt<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">看! 我们把删除的文件找回来了。 Git 的 reflog 在 rebasing 出错的时候也是同样有用的。</span><br><span class="line">我想删除一个分支</span><br><span class="line">删除一个远程分支:</span><br></pre></td></tr></table></figure></p>
<p>(master)$ git push origin –delete my-branch<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">你也可以:</span><br></pre></td></tr></table></figure></p>
<p>(master)$ git push origin :my-branch<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">删除一个本地分支:</span><br></pre></td></tr></table></figure></p>
<p>(master)$ git branch -D my-branch<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">### 我想从别人正在工作的远程分支签出(checkout)一个分支</span><br><span class="line">首先, 从远程拉取(fetch) 所有分支:</span><br></pre></td></tr></table></figure></p>
<p>(master)$ git fetch –all<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">假设你想要从远程的daves分支签出到本地的daves</span><br></pre></td></tr></table></figure></p>
<p>(master)$ git checkout –track origin/daves<br>Branch daves set up to track remote branch daves from origin.<br>Switched to a new branch ‘daves’<br>(–track 是 git checkout -b [branch] [remotename]/[branch] 的简写)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这样就得到了一个daves分支的本地拷贝, 任何推过(pushed)的更新，远程都能看到.</span><br><span class="line">## Rebasing 和合并(Merging)</span><br><span class="line">我想撤销 rebase/merge</span><br><span class="line">你可以合并(merge)或 rebase 了一个错误的分支, 或者完成不了一个进行中的 rebase/merge。 Git 在进行危险操作的时候会把原始的 HEAD 保存在一个叫 ORIG_HEAD 的变量里, 所以要把分支恢复到 rebase/merge 前的状态是很容易的。</span><br></pre></td></tr></table></figure></p>
<p>(my-branch)$ git reset –hard ORIG_HEAD<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我已经 rebase 过, 但是我不想强推(force push)</span><br><span class="line">不幸的是，如果你想把这些变化(changes)反应到远程分支上，你就必须得强推(force push)。 是因你快进(Fast forward)了提交，改变了 Git 历史, 远程分支不会接受变化(changes)，除非强推(force push)。这就是许多人使用 merge 工作流, 而不是 rebasing 工作流的主要原因之一， 开发者的强推(force push)会使大的团队陷入麻烦。使用时需要注意，一种安全使用 rebase 的方法是，不要把你的变化(changes)反映到远程分支上, 而是按下面的做:</span><br></pre></td></tr></table></figure></p>
<p>(master)$ git checkout my-branch<br>(my-branch)$ git rebase -i master<br>(my-branch)$ git checkout master<br>(master)$ git merge –ff-only my-branch<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">更多, 参见 this SO thread.</span><br><span class="line">我需要组合(combine)几个提交(commit)</span><br><span class="line">假设你的工作分支将会做对于 master 的 pull-request。 一般情况下你不关心提交(commit)的时间戳，只想组合 所有 提交(commit) 到一个单独的里面, 然后重置(reset)重提交(recommit)。 确保主(master)分支是最新的和你的变化都已经提交了, 然后:</span><br></pre></td></tr></table></figure></p>
<p>(my-branch)$ git reset –soft master<br>(my-branch)$ git commit -am “New awesome feature”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果你想要更多的控制, 想要保留时间戳, 你需要做交互式 rebase (interactive rebase):</span><br></pre></td></tr></table></figure></p>
<p>(my-branch)$ git rebase -i master<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果没有相对的其它分支， 你将不得不相对自己的HEAD 进行 rebase。 例如：你想组合最近的两次提交(commit), 你将相对于HEAD\~2 进行 rebase， 组合最近 3 次提交(commit), 相对于HEAD\~3, 等等。</span><br></pre></td></tr></table></figure></p>
<p>(master)$ git rebase -i HEAD~2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在你执行了交互式 rebase 的命令(interactive rebase command)后, 你将在你的编辑器里看到类似下面的内容:</span><br></pre></td></tr></table></figure></p>
<p>pick a9c8a1d Some refactoring<br>pick 01b2fd8 New awesome feature<br>pick b729ad5 fixup<br>pick e3851e8 another fix</p>
<h2 id="Rebase-8074d12-b729ad5-onto-8074d12"><a href="#Rebase-8074d12-b729ad5-onto-8074d12" class="headerlink" title="Rebase 8074d12..b729ad5 onto 8074d12"></a>Rebase 8074d12..b729ad5 onto 8074d12</h2><p>#</p>
<h2 id="Commands"><a href="#Commands" class="headerlink" title="Commands:"></a>Commands:</h2><h2 id="p-pick-use-commit"><a href="#p-pick-use-commit" class="headerlink" title="p, pick = use commit"></a>p, pick = use commit</h2><h2 id="r-reword-use-commit-but-edit-the-commit-message"><a href="#r-reword-use-commit-but-edit-the-commit-message" class="headerlink" title="r, reword = use commit, but edit the commit message"></a>r, reword = use commit, but edit the commit message</h2><h2 id="e-edit-use-commit-but-stop-for-amending"><a href="#e-edit-use-commit-but-stop-for-amending" class="headerlink" title="e, edit = use commit, but stop for amending"></a>e, edit = use commit, but stop for amending</h2><h2 id="s-squash-use-commit-but-meld-into-previous-commit"><a href="#s-squash-use-commit-but-meld-into-previous-commit" class="headerlink" title="s, squash = use commit, but meld into previous commit"></a>s, squash = use commit, but meld into previous commit</h2><h2 id="f-fixup-like-“squash”-but-discard-this-commit’s-log-message"><a href="#f-fixup-like-“squash”-but-discard-this-commit’s-log-message" class="headerlink" title="f, fixup = like “squash”, but discard this commit’s log message"></a>f, fixup = like “squash”, but discard this commit’s log message</h2><h2 id="x-exec-run-command-the-rest-of-the-line-using-shell"><a href="#x-exec-run-command-the-rest-of-the-line-using-shell" class="headerlink" title="x, exec = run command (the rest of the line) using shell"></a>x, exec = run command (the rest of the line) using shell</h2><p>#</p>
<h2 id="These-lines-can-be-re-ordered-they-are-executed-from-top-to-bottom"><a href="#These-lines-can-be-re-ordered-they-are-executed-from-top-to-bottom" class="headerlink" title="These lines can be re-ordered; they are executed from top to bottom."></a>These lines can be re-ordered; they are executed from top to bottom.</h2><p>#</p>
<h2 id="If-you-remove-a-line-here-THAT-COMMIT-WILL-BE-LOST"><a href="#If-you-remove-a-line-here-THAT-COMMIT-WILL-BE-LOST" class="headerlink" title="If you remove a line here THAT COMMIT WILL BE LOST."></a>If you remove a line here THAT COMMIT WILL BE LOST.</h2><p>#</p>
<h2 id="However-if-you-remove-everything-the-rebase-will-be-aborted"><a href="#However-if-you-remove-everything-the-rebase-will-be-aborted" class="headerlink" title="However, if you remove everything, the rebase will be aborted."></a>However, if you remove everything, the rebase will be aborted.</h2><p>#</p>
<h2 id="Note-that-empty-commits-are-commented-out"><a href="#Note-that-empty-commits-are-commented-out" class="headerlink" title="Note that empty commits are commented out"></a>Note that empty commits are commented out</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">所有以 # 开头的行都是注释, 不会影响 rebase.</span><br><span class="line">然后，你可以用任何上面命令列表的命令替换 pick, 你也可以通过删除对应的行来删除一个提交(commit)。</span><br><span class="line">例如, 如果你想 单独保留最旧(first)的提交(commit),组合所有剩下的到第二个里面, 你就应该编辑第二个提交(commit)后面的每个提交(commit) 前的单词为 f:</span><br></pre></td></tr></table></figure>
<p>pick a9c8a1d Some refactoring<br>pick 01b2fd8 New awesome feature<br>f b729ad5 fixup<br>f e3851e8 another fix<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果你想组合这些提交(commit) 并重命名这个提交(commit), 你应该在第二个提交(commit)旁边添加一个r，或者更简单的用s 替代 f:</span><br></pre></td></tr></table></figure></p>
<p>pick a9c8a1d Some refactoring<br>pick 01b2fd8 New awesome feature<br>s b729ad5 fixup<br>s e3851e8 another fix<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">你可以在接下来弹出的文本提示框里重命名提交(commit)。</span><br></pre></td></tr></table></figure></p>
<p>Newer, awesomer features</p>
<h2 id="Please-enter-the-commit-message-for-your-changes-Lines-starting"><a href="#Please-enter-the-commit-message-for-your-changes-Lines-starting" class="headerlink" title="Please enter the commit message for your changes. Lines starting"></a>Please enter the commit message for your changes. Lines starting</h2><h2 id="with-‘-’-will-be-ignored-and-an-empty-message-aborts-the-commit"><a href="#with-‘-’-will-be-ignored-and-an-empty-message-aborts-the-commit" class="headerlink" title="with ‘#’ will be ignored, and an empty message aborts the commit."></a>with ‘#’ will be ignored, and an empty message aborts the commit.</h2><h2 id="rebase-in-progress-onto-8074d12"><a href="#rebase-in-progress-onto-8074d12" class="headerlink" title="rebase in progress; onto 8074d12"></a>rebase in progress; onto 8074d12</h2><h2 id="You-are-currently-editing-a-commit-while-rebasing-branch-‘master’-on-‘8074d12’"><a href="#You-are-currently-editing-a-commit-while-rebasing-branch-‘master’-on-‘8074d12’" class="headerlink" title="You are currently editing a commit while rebasing branch ‘master’ on ‘8074d12’."></a>You are currently editing a commit while rebasing branch ‘master’ on ‘8074d12’.</h2><p>#</p>
<h2 id="Changes-to-be-committed-1"><a href="#Changes-to-be-committed-1" class="headerlink" title="Changes to be committed:"></a>Changes to be committed:</h2><h1 id="modified-README-md"><a href="#modified-README-md" class="headerlink" title="modified:   README.md"></a>modified:   README.md</h1><p>#<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果成功了, 你应该看到类似下面的内容:</span><br></pre></td></tr></table></figure></p>
<p>(master)$ Successfully rebased and updated refs/heads/master.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">安全合并(merging)策略</span><br><span class="line">--no-commit 执行合并(merge)但不自动提交, 给用户在做提交前检查和修改的机会。 no-ff 会为特性分支(feature branch)的存在过留下证据, 保持项目历史一致。</span><br></pre></td></tr></table></figure></p>
<p>(master)$ git merge –no-ff –no-commit my-branch<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">### 我需要将一个分支合并成一个提交(commit)</span><br></pre></td></tr></table></figure></p>
<p>(master)$ git merge –squash my-branch<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">### 我只想组合(combine)未推的提交(unpushed commit)</span><br><span class="line">有时候，在将数据推向上游之前，你有几个正在进行的工作提交(commit)。这时候不希望把已经推(push)过的组合进来，因为其他人可能已经有提交(commit)引用它们了。</span><br></pre></td></tr></table></figure></p>
<p>(master)$ git rebase -i @{u}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这会产生一次交互式的 rebase(interactive rebase), 只会列出没有推(push)的提交(commit)， 在这个列表时进行 reorder/fix/squash 都是安全的。</span><br><span class="line">检查是否分支上的所有提交(commit)都合并(merge)过了</span><br><span class="line">检查一个分支上的所有提交(commit)是否都已经合并(merge)到了其它分支, 你应该在这些分支的 head(或任何 commits)之间做一次 diff:</span><br></pre></td></tr></table></figure></p>
<p>(master)$ git log –graph –left-right –cherry-pick –oneline HEAD…feature/120-on-scroll<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这会告诉你在一个分支里有而另一个分支没有的所有提交(commit), 和分支之间不共享的提交(commit)的列表。 另一个做法可以是:</span><br></pre></td></tr></table></figure></p>
<p>(master)$ git log master ^feature/120-on-scroll –no-merges<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">### 交互式 rebase(interactive rebase)可能出现的问题</span><br><span class="line">这个 rebase 编辑屏幕出现&apos;noop&apos;</span><br><span class="line">如果你看到的是这样:</span><br></pre></td></tr></table></figure></p>
<p>noop<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这意味着你 rebase 的分支和当前分支在同一个提交(commit)上, 或者 领先(ahead) 当前分支。 你可以尝试:</span><br><span class="line"></span><br><span class="line">检查确保主(master)分支没有问题</span><br></pre></td></tr></table></figure></p>
<p>rebase HEAD~2 或者更早<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">有冲突的情况</span><br><span class="line">如果你不能成功的完成 rebase, 你可能必须要解决冲突。</span><br><span class="line">首先执行 git status 找出哪些文件有冲突:</span><br></pre></td></tr></table></figure></p>
<p>(my-branch)$ git status<br>On branch my-branch<br>Changes not staged for commit:<br>  (use “git add <file>…” to update what will be committed)<br>  (use “git checkout – <file>…” to discard changes in working directory)</file></file></p>
<pre><code>modified:   README.md
</code></pre><p>在这个例子里面, README.md 有冲突。 打开这个文件找到类似下面的内容:<br>   &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</p>
<h1 id="some-code"><a href="#some-code" class="headerlink" title="   some code"></a>   some code</h1><p>   some code</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>new-commit<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">你需要解决新提交的代码(示例里, 从中间==线到new-commit的地方)与HEAD 之间不一样的地方.</span><br><span class="line">有时候这些合并非常复杂，你应该使用可视化的差异编辑器(visual diff editor):</span><br><span class="line">(master*)$ git mergetool -t opendiff</span><br><span class="line">在你解决完所有冲突和测试过后, git add 变化了的(changed)文件, 然后用git rebase --continue 继续 rebase。</span><br></pre></td></tr></table></figure></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>(my-branch)$ git add README.md<br>(my-branch)$ git rebase –continue<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果在解决完所有的冲突过后，得到了与提交前一样的结果, 可以执行git rebase --skip。</span><br><span class="line">任何时候你想结束整个 rebase 过程，回来 rebase 前的分支状态, 你可以做:</span><br></pre></td></tr></table></figure></p>
<p>(my-branch)$ git rebase –abort<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">## 杂项(Miscellaneous Objects)</span><br><span class="line">### 克隆所有子模块</span><br></pre></td></tr></table></figure></p>
<p>$ git clone –recursive git://github.com/foo/bar.git<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果已经克隆了:</span><br></pre></td></tr></table></figure></p>
<p>$ git submodule update –init –recursive<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">### 删除标签(tag)</span><br></pre></td></tr></table></figure></p>
<p>$ git tag -d &lt;tag_name&gt;<br>$ git push <remote> :refs/tags/&lt;tag_name&gt;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">### 恢复已删除标签(tag)</span><br><span class="line">如果你想恢复一个已删除标签(tag), 可以按照下面的步骤: 首先, 需要找到无法访问的标签(unreachable tag):</span><br></pre></td></tr></table></figure></remote></p>
<p>$ git fsck –unreachable | grep tag<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">记下这个标签(tag)的 hash，然后用 Git 的 update-ref:</span><br></pre></td></tr></table></figure></p>
<p>$ git update-ref refs/tags/&lt;tag_name&gt; <hash><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">这时你的标签(tag)应该已经恢复了。</span><br><span class="line">### 已删除补丁(patch)</span><br><span class="line">如果某人在 GitHub 上给你发了一个 pull request, 但是然后他删除了他自己的原始 fork, 你将没法克隆他们的提交(commit)或使用 git am。在这种情况下, 最好手动的查看他们的提交(commit)，并把它们拷贝到一个本地新分支，然后做提交。</span><br><span class="line">做完提交后, 再修改作者，参见变更作者。 然后, 应用变化, 再发起一个新的 pull request。</span><br><span class="line">## 跟踪文件(Tracking Files)</span><br><span class="line">我只想改变一个文件名字的大小写，而不修改内容</span><br></pre></td></tr></table></figure></hash></p>
<p>(master)$ git mv –force myfile MyFile<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">### 我想从 Git 删除一个文件，但保留该文件</span><br></pre></td></tr></table></figure></p>
<p>(master)$ git rm –cached log.txt<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">## 配置(Configuration)</span><br><span class="line">### 我想给一些 Git 命令添加别名(alias)</span><br><span class="line">在 OS X 和 Linux 下, 你的 Git 的配置文件储存在 \~/.gitconfig。我在[alias] 部分添加了一些快捷别名(和一些我容易拼写错误的)，如下:</span><br></pre></td></tr></table></figure></p>
<p>[alias]<br>    a = add<br>    amend = commit –amend<br>    c = commit<br>    ca = commit –amend<br>    ci = commit -a<br>    co = checkout<br>    d = diff<br>    dc = diff –changed<br>    ds = diff –staged<br>    f = fetch<br>    loll = log –graph –decorate –pretty=oneline –abbrev-commit<br>    m = merge<br>    one = log –pretty=oneline<br>    outstanding = rebase -i @{u}<br>    s = status<br>    unpushed = log @{u}<br>    wc = whatchanged<br>    wip = rebase -i @{u}<br>    zap = fetch -p<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">### 我想缓存一个仓库(repository)的用户名和密码</span><br><span class="line">你可能有一个仓库需要授权，这时你可以缓存用户名和密码，而不用每次推/拉(push/pull)的时候都输入，Credential helper 能帮你。</span><br></pre></td></tr></table></figure></p>
<p>$ git config –global credential.helper cache</p>
<h2 id="Set-git-to-use-the-credential-memory-cache"><a href="#Set-git-to-use-the-credential-memory-cache" class="headerlink" title="Set git to use the credential memory cache"></a>Set git to use the credential memory cache</h2><p>$ git config –global credential.helper ‘cache –timeout=3600’</p>
<h2 id="Set-the-cache-to-timeout-after-1-hour-setting-is-in-seconds"><a href="#Set-the-cache-to-timeout-after-1-hour-setting-is-in-seconds" class="headerlink" title="Set the cache to timeout after 1 hour (setting is in seconds)"></a>Set the cache to timeout after 1 hour (setting is in seconds)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">## 我不知道我做错了些什么</span><br><span class="line">你把事情搞砸了：你 重置(reset) 了一些东西, 或者你合并了错误的分支, 亦或你强推了后找不到你自己的提交(commit)了。有些时候, 你一直都做得很好, 但你想回到以前的某个状态。</span><br><span class="line">这就是 git reflog 的目的， reflog 记录对分支顶端(the tip of a branch)的任何改变, 即使那个顶端没有被任何分支或标签引用。基本上, 每次 HEAD 的改变, 一条新的记录就会增加到reflog。遗憾的是，这只对本地分支起作用，且它只跟踪动作 (例如，不会跟踪一个没有被记录的文件的任何改变)。</span><br></pre></td></tr></table></figure>
<p>(master)$ git reflog<br>0a2e358 HEAD@{0}: reset: moving to HEAD~2<br>0254ea7 HEAD@{1}: checkout: moving from 2.2 to master<br>c10f740 HEAD@{2}: checkout: moving from master to 2.2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">上面的 reflog 展示了从 master 分支签出(checkout)到 2.2 分支，然后再签回。 那里，还有一个硬重置(hard reset)到一个较旧的提交。最新的动作出现在最上面以 HEAD@&#123;0&#125;标识.</span><br><span class="line">如果事实证明你不小心回移(move back)了提交(commit), reflog 会包含你不小心回移前 master 上指向的提交(0254ea7)。</span><br></pre></td></tr></table></figure></p>
<p>$ git reset –hard 0254ea7<br><code>`</code><br>然后使用 git reset 就可以把 master 改回到之前的 commit，这提供了一个在历史被意外更改情况下的安全网。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>最后，放一张我总结的脑图总结一下以上的知识点。</p>
<p><img src="/images/pasted-23.png" alt="upload successful"></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>官方资源</li>
</ul>
<p>Git 官网<br>Git Github</p>
<ul>
<li>模板</li>
</ul>
<p>gitignore 模板 - .gitignore 文件模板<br>gitattributes 模板 - .gitattributes 文件模板<br>github-cheat-sheet - git 命令简略图表</p>
<ul>
<li>Git 书</li>
</ul>
<p>Git 官方推荐教程 - Scott Chacon 的 Git 书。</p>
<ul>
<li>Git 教程</li>
</ul>
<p>Git 中文教程<br>廖雪峰的 Git 教程<br>有关 git 的学习资源</p>
<ul>
<li>文章</li>
</ul>
<p>Git Cookbook<br>Git 奇技淫巧<br>Git 风格指南<br>Git 在团队中的最佳实践–如何正确使用 Git Flow</p>
<ul>
<li>Git 工具</li>
</ul>
<p>guis - Git 官网展示的客户端工具列表。<br>gogs - 极易搭建的自助 Git 服务。<br>gitflow - 应用 fit-flow 模型的工具。<br>firstaidgit.io 一个可搜索的最常被问到的 Git 的问题<br>git-extra-commands - 一堆有用的额外的 Git 脚本<br>git-extras - GIT 工具集 – repo summary, repl, changelog population, author commit percentages and more<br>git-fire - git-fire 是一个 Git 插件，用于帮助在紧急情况下添加所有当前文件, 做提交(committing), 和推(push)到一个新分支(阻止合并冲突)。<br>git-tips - Git 小提示<br>git-town - 通用，高级 Git 工作流支持！ <a href="http://www.git-town.com" target="_blank" rel="noopener">http://www.git-town.com</a></p>
<ul>
<li>GUI 客户端(GUI Clients)</li>
</ul>
<p>GitKraken - 豪华的 Git 客户端 Windows, Mac &amp; Linux<br>git-cola - 另外一个 Git 客户端 Windows &amp; OS X<br>GitUp - 一个新的 Git 客户端，在处理 Git 的复杂性上有自己的特点<br>gitx-dev - 图形化的 Git 客户端 OS X<br>Source Tree - 免费的图形化 Git 客户端 Windows &amp; OS X<br>Tower - 图形化 Git 客户端 OS X(付费)</p>
<p>git cheat sheet</p>
<p>github-git-cheat-sheet</p>
<p>作者：forbreak<br>链接：<a href="https://juejin.im/post/5c8296f85188257e3941b2d4" target="_blank" rel="noopener">https://juejin.im/post/5c8296f85188257e3941b2d4</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/git/" rel="tag"># git</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/post/41b8a8bd.html" rel="next" title="安装配置环境">
                <i class="fa fa-chevron-left"></i> 安装配置环境
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="cacacai">
            
              <p class="site-author-name" itemprop="name">cacacai</p>
              <p class="site-description motion-element" itemprop="description">夏天的飞鸟飞到我的窗前唱歌又飞去了秋天的黄叶它们没有什么可唱只叹息一声飞落在那里</p>
          </div>

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#简介"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Git-是什么？"><span class="nav-number">1.1.</span> <span class="nav-text">Git 是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是版本控制？"><span class="nav-number">1.2.</span> <span class="nav-text">什么是版本控制？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是分布式版本控制系统？"><span class="nav-number">1.3.</span> <span class="nav-text">什么是分布式版本控制系统？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么使用-Git？"><span class="nav-number">1.4.</span> <span class="nav-text">为什么使用 Git？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#安装"><span class="nav-number">2.</span> <span class="nav-text">安装</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Debian-Ubuntu-环境安装"><span class="nav-number">2.1.</span> <span class="nav-text">Debian/Ubuntu 环境安装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Centos-RedHat-环境安装"><span class="nav-number">2.2.</span> <span class="nav-text">Centos/RedHat 环境安装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Windows-环境安装"><span class="nav-number">2.3.</span> <span class="nav-text">Windows 环境安装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mac-环境安装"><span class="nav-number">2.4.</span> <span class="nav-text">Mac 环境安装</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#配置"><span class="nav-number">3.</span> <span class="nav-text">配置</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#用户信息"><span class="nav-number">3.1.</span> <span class="nav-text">用户信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gitignore"><span class="nav-number">3.2.</span> <span class="nav-text">.gitignore</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#原理"><span class="nav-number">4.</span> <span class="nav-text">原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#版本库"><span class="nav-number">4.1.</span> <span class="nav-text">版本库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#哈希值"><span class="nav-number">4.2.</span> <span class="nav-text">哈希值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件状态"><span class="nav-number">4.3.</span> <span class="nav-text">文件状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#工作区域"><span class="nav-number">4.4.</span> <span class="nav-text">工作区域</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#命令"><span class="nav-number">5.</span> <span class="nav-text">命令</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#创建仓库"><span class="nav-number">5.1.</span> <span class="nav-text">创建仓库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#添加修改"><span class="nav-number">5.2.</span> <span class="nav-text">添加修改</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#储藏"><span class="nav-number">5.3.</span> <span class="nav-text">储藏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#撤销修改"><span class="nav-number">5.4.</span> <span class="nav-text">撤销修改</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#更新与推送"><span class="nav-number">5.5.</span> <span class="nav-text">更新与推送</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查看信息"><span class="nav-number">5.6.</span> <span class="nav-text">查看信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分支"><span class="nav-number">5.7.</span> <span class="nav-text">分支</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#切换分支："><span class="nav-number">5.8.</span> <span class="nav-text">切换分支：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#合并与重置"><span class="nav-number">5.9.</span> <span class="nav-text">合并与重置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Github"><span class="nav-number">5.10.</span> <span class="nav-text">Github</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#clone-方式"><span class="nav-number">5.11.</span> <span class="nav-text">clone 方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#生成-SSH-公钥"><span class="nav-number">5.12.</span> <span class="nav-text">生成 SSH 公钥</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#最佳实践-Git-Flow"><span class="nav-number">6.</span> <span class="nav-text">最佳实践 Git Flow</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#常见问题"><span class="nav-number">7.</span> <span class="nav-text">常见问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#编辑提交-editting-commits"><span class="nav-number">7.1.</span> <span class="nav-text">编辑提交(editting commits)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#我刚才提交了什么"><span class="nav-number">7.1.1.</span> <span class="nav-text">我刚才提交了什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#我的提交信息-commit-message-写错了"><span class="nav-number">7.1.2.</span> <span class="nav-text">我的提交信息(commit message)写错了</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#我提交-commit-里的用户名和邮箱不对"><span class="nav-number">7.1.3.</span> <span class="nav-text">我提交(commit)里的用户名和邮箱不对</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#我想从一个提交-commit-里移除一个文件"><span class="nav-number">7.1.4.</span> <span class="nav-text">我想从一个提交(commit)里移除一个文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除任意提交-commit"><span class="nav-number">7.1.5.</span> <span class="nav-text">删除任意提交(commit)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#我尝试推一个修正后的提交-amended-commit-到远程，但是报错："><span class="nav-number">7.1.6.</span> <span class="nav-text">我尝试推一个修正后的提交(amended commit)到远程，但是报错：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#我意外的做了一次硬重置-hard-reset-，我想找回我的内容"><span class="nav-number">7.1.7.</span> <span class="nav-text">我意外的做了一次硬重置(hard reset)，我想找回我的内容</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#暂存-Staging"><span class="nav-number">7.2.</span> <span class="nav-text">暂存(Staging)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#我需要把暂存的内容添加到上一次的提交-commit"><span class="nav-number">7.2.1.</span> <span class="nav-text">我需要把暂存的内容添加到上一次的提交(commit)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#我想要暂存一个新文件的一部分，而不是这个文件的全部"><span class="nav-number">7.2.2.</span> <span class="nav-text">我想要暂存一个新文件的一部分，而不是这个文件的全部</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#我想把在一个文件里的变化-changes-加到两个提交-commit-里"><span class="nav-number">7.2.3.</span> <span class="nav-text">我想把在一个文件里的变化(changes)加到两个提交(commit)里</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#one-commit"><span class="nav-number">7.3.</span> <span class="nav-text">one commit</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#two-commits"><span class="nav-number">7.4.</span> <span class="nav-text">two commits</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#four-commits"><span class="nav-number">7.5.</span> <span class="nav-text">four commits</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#or"><span class="nav-number">7.6.</span> <span class="nav-text">or</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Answer-y-to-all-of-the-snippets-you-want-to-drop"><span class="nav-number">7.7.</span> <span class="nav-text">Answer y to all of the snippets you want to drop</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Select-all-of-the-snippets-you-want-to-save"><span class="nav-number">7.8.</span> <span class="nav-text">Select all of the snippets you want to save</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Select-all-of-the-snippets-you-don’t-want-to-save"><span class="nav-number">7.9.</span> <span class="nav-text">Select all of the snippets you don’t want to save</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#On-branch-my-branch"><span class="nav-number">7.10.</span> <span class="nav-text">On branch my-branch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Your-branch-is-ahead-of-‘origin-my-branch’-by-2-commits"><span class="nav-number">7.11.</span> <span class="nav-text">Your branch is ahead of ‘origin/my-branch’ by 2 commits.</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#use-“git-push”-to-publish-your-local-commits"><span class="nav-number">7.12.</span> <span class="nav-text">(use “git push” to publish your local commits)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#On-branch-develop"><span class="nav-number">7.13.</span> <span class="nav-text">On branch develop</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Your-branch-is-up-to-date-with-‘origin-develop’"><span class="nav-number">7.14.</span> <span class="nav-text">Your branch is up-to-date with ‘origin/develop’.</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Changes-to-be-committed"><span class="nav-number">7.15.</span> <span class="nav-text">Changes to be committed:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#use-“git-reset-HEAD-…”-to-unstage"><span class="nav-number">7.16.</span> <span class="nav-text">(use “git reset HEAD …” to unstage)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#modified-file1-txt"><span class="nav-number">7.17.</span> <span class="nav-text">modified:   file1.txt</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Rebase-8074d12-b729ad5-onto-8074d12"><span class="nav-number">7.18.</span> <span class="nav-text">Rebase 8074d12..b729ad5 onto 8074d12</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Commands"><span class="nav-number">7.19.</span> <span class="nav-text">Commands:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#p-pick-use-commit"><span class="nav-number">7.20.</span> <span class="nav-text">p, pick = use commit</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#r-reword-use-commit-but-edit-the-commit-message"><span class="nav-number">7.21.</span> <span class="nav-text">r, reword = use commit, but edit the commit message</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#e-edit-use-commit-but-stop-for-amending"><span class="nav-number">7.22.</span> <span class="nav-text">e, edit = use commit, but stop for amending</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#s-squash-use-commit-but-meld-into-previous-commit"><span class="nav-number">7.23.</span> <span class="nav-text">s, squash = use commit, but meld into previous commit</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#f-fixup-like-“squash”-but-discard-this-commit’s-log-message"><span class="nav-number">7.24.</span> <span class="nav-text">f, fixup = like “squash”, but discard this commit’s log message</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#x-exec-run-command-the-rest-of-the-line-using-shell"><span class="nav-number">7.25.</span> <span class="nav-text">x, exec = run command (the rest of the line) using shell</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#These-lines-can-be-re-ordered-they-are-executed-from-top-to-bottom"><span class="nav-number">7.26.</span> <span class="nav-text">These lines can be re-ordered; they are executed from top to bottom.</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#If-you-remove-a-line-here-THAT-COMMIT-WILL-BE-LOST"><span class="nav-number">7.27.</span> <span class="nav-text">If you remove a line here THAT COMMIT WILL BE LOST.</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#However-if-you-remove-everything-the-rebase-will-be-aborted"><span class="nav-number">7.28.</span> <span class="nav-text">However, if you remove everything, the rebase will be aborted.</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Note-that-empty-commits-are-commented-out"><span class="nav-number">7.29.</span> <span class="nav-text">Note that empty commits are commented out</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Please-enter-the-commit-message-for-your-changes-Lines-starting"><span class="nav-number">7.30.</span> <span class="nav-text">Please enter the commit message for your changes. Lines starting</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#with-‘-’-will-be-ignored-and-an-empty-message-aborts-the-commit"><span class="nav-number">7.31.</span> <span class="nav-text">with ‘#’ will be ignored, and an empty message aborts the commit.</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rebase-in-progress-onto-8074d12"><span class="nav-number">7.32.</span> <span class="nav-text">rebase in progress; onto 8074d12</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#You-are-currently-editing-a-commit-while-rebasing-branch-‘master’-on-‘8074d12’"><span class="nav-number">7.33.</span> <span class="nav-text">You are currently editing a commit while rebasing branch ‘master’ on ‘8074d12’.</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Changes-to-be-committed-1"><span class="nav-number">7.34.</span> <span class="nav-text">Changes to be committed:</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#modified-README-md"><span class="nav-number">8.</span> <span class="nav-text">modified:   README.md</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#some-code"><span class="nav-number">9.</span> <span class="nav-text">   some code</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Set-git-to-use-the-credential-memory-cache"><span class="nav-number">9.1.</span> <span class="nav-text">Set git to use the credential memory cache</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Set-the-cache-to-timeout-after-1-hour-setting-is-in-seconds"><span class="nav-number">9.2.</span> <span class="nav-text">Set the cache to timeout after 1 hour (setting is in seconds)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#小结"><span class="nav-number">10.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考资料"><span class="nav-number">11.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cacacai</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数"></span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长"></span>
  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v6.7.0</div>




        








        
      </div>
    </footer>

    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
















  
  











  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script src="/lib/three/three.min.js"></script>

  
  <script src="/lib/three/three-waves.min.js"></script>


  


  <script src="/js/src/utils.js?v=6.7.0"></script>

  <script src="/js/src/motion.js?v=6.7.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.7.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.7.0"></script>




  
  <script src="/js/src/scrollspy.js?v=6.7.0"></script>
<script src="/js/src/post-details.js?v=6.7.0"></script>



  


  <script src="/js/src/bootstrap.js?v=6.7.0"></script>



  
  

<script src="//cdn1.lncld.net/static/js/3.11.1/av-min.js"></script>



<script src="//unpkg.com/valine/dist/Valine.min.js"></script>

<script>
  var GUEST = ['nick', 'mail', 'link'];
  var guest = '昵称,邮箱,网址';
  guest = guest.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'YUDKI6iMvLCHyttuxYWbMpWc-gzGzoHsz',
    appKey: 'j5QadiIkFQuWd0RLYXGHhCQ1',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false
  });
</script>




  


  

  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

  

  

  

  

  

  

  

  
 <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;"></canvas> 
 <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
 <script type="text/javascript" src="/js/src/fireworks.js"></script>


<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
